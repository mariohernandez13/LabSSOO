#include "banco.h"

CONFIG configuracion;
int contadorAlertas;

void menuAdmin()
{
    char contrase√±a[50] = "";
    int opcion = 0;
    char *comparacion = 0;

    system("clear");
    printf("=====================================\n");
    printf("Introduce la contrase√±a: \n");
    while(getchar() != '\n');
    fgets(contrase√±a, sizeof(contrase√±a), stdin);

    comparacion = strstr(contrase√±a, "admin");

    if (!comparacion)
    {
        escrituraLogGeneral("üü• Contrase√±a incorrecta\n", 0);
        return;
    }
    else
    {
        escrituraLogGeneral("Contrase√±a correcta, accediendo al men√∫ de administrador\n", 0);
        do{

            system("clear");
            printf("=====================================\n");
            printf("       üåü BIENVENIDO ADMIN üåü        \n");
            printf("=====================================\n");
            printf("1. Mostrar configuracion actual\n");
            printf("2. Mostrar arbol de procesos de la aplicacion\n");
            printf("3. Mostrar semaforos activos en el sistema\n");
            printf("4. Mostrar pid de banco con el pid de los usuarios hijos\n");
            printf("5. Mostrar hilos activos actualmente\n");
            printf("6. Salir\n");
            printf("=====================================\n");
            printf("üëâ Introduce una opci√≥n: ");
            scanf("%d", &opcion);

            switch (opcion)
            {
                case 3:
                    printf("\n");
                    printf("=====================================\n");
                    printf("üö¶ Los sem√°foros activos en el sistema son: \n");
                    system("ls /dev/shm/");
                    printf("=====================================\n");
                    sleep(5);
                    break;
                case 6:
                    break;
            }
        }while (opcion != 6);
    }
    return;
}

/// @brief Funci√≥n que se encarga de recibir alertas de la tuber√≠a FIFO creada entre Monitor y Banco
/// @return NULL
/// @note Se ejecuta en un hilo por separado para no interrumpir el flujo principal del programa
void *recibirAlertas()
{
    int fifo_fd;
    char buffer[256];

    // Verificar si la FIFO ya existe

    if (mkfifo(FIFO1, 0666) == -1)
    {
        escrituraLogGeneral("üü• Error al crear la tuber√≠a FIFO1 en banco\n", 0);
    }

    fifo_fd = open(FIFO1, O_RDONLY);

    if (fifo_fd == -1)
    {
        escrituraLogGeneral("üü• Error al abrir la tuber√≠a en banco", 0);
    }

    while (1)
    {
        ssize_t bytesRead = read(fifo_fd, buffer, sizeof(buffer));
        if (bytesRead > 0)
        {
            buffer[strcspn(buffer, "\n")] = 0; // Limpiar \n al final del mensaje
            escrituraLogGeneral("üö® ALERTA RECIBIDA\n", 0);
            contadorAlertas++;
        }
        else if (bytesRead == -1)
        {
            escrituraLogGeneral("üü• Error al leer de la tuber√≠a FIFO1\n", 0);
            break;
        }
        sleep(1);
    }

    close(fifo_fd);
    return NULL;
}

/// @brief Limpia los strings de "\n"
/// @param string String que queremos "limpiar" de caracteres indeseados
void limpiezaString(char *string)
{
    for (int i = 0; i < strlen(string); i++)
        if (string[i] == '\n')
            string[i] = '\0';
}


/// @brief Funci√≥n que se encarga de registrar uan nueva cuenta en el sistema del banco
/// @param cuenta Parametros de la nueva cuenta
void registroCuenta(Cuenta cuenta)
{
    FILE *fileCuenta;
    FILE *fileError;
    char linea[MAX_LINE_LENGTH] = "";
    char lineaError[MAX_LINE_LENGTH] = "";

    // Limpiamos los "\n" de nombre y de saldo porque vienen con dichos caracteres
    limpiezaString(cuenta.titular);
    limpiezaString(cuenta.saldo);

    semaforo_cuentas = sem_open("/semaforo_cuentas", O_CREAT, 0644, 1);
    semaforo_banco = sem_open("/semaforo_banco", O_CREAT, 0644, 1);

    // Si la apertura de cualquiera de los semaforos es erronea, se desestima la funcion y mandamos un log
    if (semaforo_cuentas == SEM_FAILED || semaforo_banco == SEM_FAILED)
    {
        escrituraLogGeneral("Error al abrir uno de los semaforos a la hora de hacer un resgistro", 0);
        exit(1);
    }

    sem_wait(semaforo_cuentas);
    fileCuenta = fopen("data/cuentas.dat", "a+");

    if (fileCuenta == NULL)
    {
        escrituraLogGeneral("üü• Error al abrir el archivo de cuentas\n", 0);
        fclose(fileCuenta);
        return;
    }

    fileError = fopen("data/errores.dat", "a+");

    // Si el archivo falla paramos la funcion y mandamos un log a banco.log
    if (fileError == NULL)
    {
        escrituraLogGeneral("üü• Error al abrir el archivo de errores\n", 0);
        fclose(fileError);
        return;
    }

    // Concatenamos los strings pasados como valores
    strcpy(linea, "\n");
    strcat(linea, cuenta.numero_cuenta);
    strcat(linea, ",");
    strcat(linea, cuenta.titular);
    strcat(linea, ",");
    strcat(linea, cuenta.saldo);
    strcat(linea, ",");
    strcat(linea, "0");

    fputs(linea, fileCuenta);

    escrituraLogGeneral("Se ha creado un nuevo usuario en el sistema del banco\n", 0);

    fclose(fileCuenta);

    // Concatenamos strings para formar la linea a a√±adir en el archivo de errores.dat
    strcpy(lineaError, "\n");
    strcat(lineaError, cuenta.numero_cuenta);
    strcat(lineaError, ",");
    strcat(lineaError, "0");
    strcat(lineaError, ",");
    strcat(lineaError, "0");
    strcat(lineaError, ",");
    strcat(lineaError, "0");
    
    // Ponemos la linea de error en el archivo de errores.dat
    fputs(lineaError, fileError);

    escrituraLogGeneral("Se ha creado un nuevo usuario en el sistema del banco. Se ha creado una nueva fila en errores.dat\n", 0);

    fclose(fileError);

    // Manejamos los semaforos para evitar problemas de concurrencia
    sem_post(semaforo_cuentas);
    sem_close(semaforo_cuentas);
    sem_close(semaforo_banco);
}

/// @brief Funci√≥n que comprueba si el id pasado como par√°metro se encuentra en el archivo "cuentas.dat"
/// @param id Id que queremos comprobar, desde el login o desde el registro
/// @param flag Variable que nos indica si nos encontramos ante un caso de LogIn o de registro
/// @return Devuelve un valor num√©rico que indica si es v√°lido el id o no: 0 = error en id // 1 = id valido
int existeID(char *id, int flag)
{

    limpiezaString(id);

    int esValido = 1;
    FILE *file;
    char linea[MAX_LINE_LENGTH] = "";
    char *key, *value;

    sem_unlink("/semaforo_cuentas");
    semaforo_cuentas = sem_open("/semaforo_cuentas", O_CREAT, 0644, 1);

    if (semaforo_cuentas == SEM_FAILED)
    {
        perror("Error al abrir los sem√°foros");
        exit(1);
    }

    sem_wait(semaforo_cuentas);

    file = fopen("data/cuentas.dat", "r");

    if (file == NULL)
    {
        escrituraLogGeneral("üü• Error al abrir el archivo de cuentas\n", 0);
        return 0;
    }

    while (fgets(linea, sizeof(linea), file))
    {
        linea[strcspn(linea, "\n")] = 0;
        key = strtok(linea, ",");
        if (flag == 0)
        {
            if (strcmp(key, id) == 0)
            {
                escrituraLogGeneral("El id ya existe\n", 0);
                esValido = 0;
                break;
            }
        }
        else if (flag == 1)
        {
            if (strcmp(key, id) == 0)
            {
                esValido = 1;
                break;
            }
            else
                esValido = 0;
        }
    }

    fclose(file);

    sem_post(semaforo_cuentas);
    sem_close(semaforo_cuentas);

    return esValido;
}

/// @brief Comprueba en el archivo de cuentas.dat que el id introducido no existe
/// @param id Id introducido por el usuario en el resgistro
/// @param flag Valor que indica si se est√° llegando a la funci√≥n desde LogIn o desde registro: 0 = registro || 1 = LogIn
/// @return Valor num√©rico que indica validez del Id: 0 = error en id // 1 = id valido
int comprobarId(char *id, int flag)
{

    int validez = 1;
    if (atoi(id) < 1000)
    {
        validez = 0;
        escrituraLogGeneral("üü• El id introducido no es v√°lido debido a que es menor a 1000\n", 0);
        return validez;
    }

    validez = existeID(id, flag);

    return validez;
}

/// @brief Men√∫ de registro del Banco
void registro()
{

    Cuenta cuenta;

    int comprobacion = 1;

    do
    {
        if (!comprobacion)
            printf("Ha ocurrido un error en tu intento de registro, prueba a volver a intentarlo.\n");

        printf("Bienvenido al registro de SafeBank\n");

        printf("Introduce tu nombre: (no se admiten m√°s de 50 caracteres): \n");
        while (getchar() != '\n')
            ; // Limpieza de buffer de entrada para evitar problemas en lectura de parametros
        fgets(cuenta.titular, sizeof(cuenta.titular), stdin);

        printf("Introduce tu id: (a partir de 100): \n");
        fgets(cuenta.numero_cuenta, sizeof(cuenta.numero_cuenta), stdin);

        printf("Introduce tu saldo: \n");
        fgets(cuenta.saldo, sizeof(cuenta.saldo), stdin);

        comprobacion = comprobarId(cuenta.numero_cuenta, 0);
    } while ((comprobacion != 1) || (cuenta.titular == NULL) || (strlen(cuenta.titular) > MAX_LENGTH_NAME));

    registroCuenta(cuenta);
}

/// @brief Men√∫ de logIn del Banco
void logIn()
{

    char id[MAX_LENGTH_ID];
    int flg_log = 1;
    int comprobacion = 1;
    pid_t pid;

    
    do
    {
        int c;
        while ((c = getchar()) != '\n' && c != EOF);
        
        system("clear");

        printf("=====================================\n");
        printf("üîê Bienvenido al LogIn de SafeBank        \n");
        printf("=====================================\n");
        printf("üí≥ Introduce tu ID (debe ser 1000 o mayor): ");

        fflush(stdout);

        if (fgets(id, sizeof(id), stdin) == NULL) {
            printf("‚ùå Error al leer el ID. Intenta nuevamente.\n");
            continue;
        }

        printf("\n‚úÖ ID ingresado: %s\n", id);
        printf("=====================================\n");

        comprobacion = comprobarId(id, flg_log);

        if (!comprobacion)
        {
            printf("‚ùå ID inv√°lido o no registrado. Por favor, intenta nuevamente.\n");
        }

    } while (!comprobacion);

    pid = fork();

    // Comprobamos que fork() no genera un error
    if (pid < 0)
    {
        escrituraLogGeneral("üü• Error al crear la sesi√≥n de LogIn\n", 0);
        return;
    }
    else if (pid == 0)
    { // Proceso hijo
        execlp("gnome-terminal", "gnome-terminal", "--", "./usuario", id, NULL);
        escrituraLogGeneral("üü• Error al ejecutar ./usuario\n", 0);
        exit(1);
    }
}

/// @brief funci√≥n que crea el hilopara leer la tuber√≠a constantemente
void iniciarHiloAlerta()
{
    pthread_t hiloAlerta;

    // Crear el hilo para recibir alertas
    if (pthread_create(&hiloAlerta, NULL, &recibirAlertas, NULL) != 0)
    {
        escrituraLogGeneral("üü• Error al crear el hilo de alertas\n", 0);
    }
}

/// @brief Men√∫ de inicio del Banco SafeBank
void menuBanco()
{
    int opcion = 0;

    do
    {
        if (contadorAlertas != 0)
        {
            contadorAlertas = 0;
            system("clear");
            printf("===================================\n");
            printf("üö® ALERTA RECIBIDA\n");
            sleep(1);
            printf("üö® ALERTA RECIBIDA\n");
            sleep(1);
            printf("üö® ALERTA RECIBIDA\n");
            sleep(1);
            printf("===================================\n");
            sleep(3);
        }

        system("clear");

        printf("=====================================\n");
        printf("  üè¶ Bienvenido a SafeBank üè¶         \n");
        printf("=====================================\n");
        printf("üíº ¬øQu√© desea hacer?\n");
        printf("üîπ 1. Inicio de Sesi√≥n\n");
        printf("üîπ 2. Registro\n");
        printf("üîπ 3. Salir\n");
        printf("=====================================\n");
        printf("üëâ Introduce una opci√≥n: ");

        scanf("%d", &opcion);

        printf("\n");
        printf("‚úÖ Opci√≥n seleccionada: %d\n", opcion);
        printf("=====================================\n");

        switch (opcion)
        {
        case 0:
            menuAdmin();
            break;
        case 1:
            logIn();
            break;
        case 2:
            registro(); // Llamamos a funcion registro
            break;
        default:
            break;
        }

    } while (opcion != 3);
    system("clear");
}

int main(int argc, char *argv[])
{
    unlink(FIFO1);
    unlink(FIFO2);

    pid_t pid = fork();

    if (pid == 0)
    {
        execlp("gnome-terminal", "gnome-terminal", "--", "./monitor", NULL);
        escrituraLogGeneral("Error al ejecutar ./monitor\n", 0);
        exit(1);
    }

    int fd[2];

    char buffer[100];
    char errorMessage[] = "Ha habido un error leyendo el archivo .config";
    char validMessage[] = "Todo correcto maquina";

    int state = 0;

    // Comprobamos que no ocurre problema al generar la pipe
    if (pipe(fd) == -1)
    {
        escrituraLogGeneral("üü• Error en la generaci√≥n de la pipe\n", 0);
        return 1;
    }

    configuracion = leer_configuracion(configuracion);

    iniciarHiloAlerta();

    menuBanco();

    system("pkill -f usuario"); // cuando cerramos banco matamos todos los procesos de usuarios
    system("pkill -f './monitor'");

    return (0);
}